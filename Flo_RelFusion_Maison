// Yop, j'ai repris sur papier tout mon code, a tête reposée. je vais essayer de recoder toutes mes fonctions ce soir sans compiler donc surement plein d'erreur

Elf_reader.h =>
/* Structure : Super-Structure des relocalisation. 
Ajout des informations concernant l'indice de la section de relocation et son nom, ainsi que le nombre de relocations à effectuer */
typedef struct reloctable {
  Elf32_Rel * tablerel;
  int indice_section;
  int nombre_relocation
  char * nom_section
} Reloctable ;


/* Ajout du type Reloctable à la place du type Elf32_Rel */
typedef struct fichierElf {
	Elf32_Ehdr	header_elf;
	Elf32_Shdr	*sectionsTable;
	Symbole	*tabSymbole;
	Elf32_Sym	*tabSymboleDynamique;
	FILE 	 	*fichierElf;
	Reloctable	*tabRel;
} FichierElf;

elf_fusionrel.c 


Reloctable* crea_rel_table (FichierElf * elfile) {
	// Creation de la table de REL
	// Avant : malloc le elf32_Rel de elfile en utilisant relsize.
	Elf32_Ehdr header = elfile->header_elf;
	Elf32_Shdr* section_headers = elfile->sectionsTable;
	// Faut-il le malloc ???
	Reloctable* tabrel = elfile->tabRel;
	FILE *elf = elfile->fichierElf;

	int nb_sec = header.e_shnum;	
	int nombre = 0;
	int trel = sizeof(Elf32_Rel);
	int k=0;
	int diffsec = 0;
	for (int i=0; i < nb_sec; i++){
		if (section_headers[i].sh_type == SHT_REL) {
			fseek(elf, section_headers[i].sh_offset, SEEK_SET);
			nombre = section_headers[i].sh_size / section_headers[i].sh_entsize;
			
			tabrel[diffsec].indice_section = i;
			tabrel[diffsec].nombre_relocation = nombre;
			tabrel[diffsec].nom_section = 
			for (int j=0; j < nombre; j++) {
				fread(&(tabrel.tablerel[k]),trel, 1,elf);
				k++;
			}
			diffsec ++;
		}


	}	
	return reltab;
}
