// Yop, j'ai repris sur papier tout mon code, a tête reposée. je vais essayer de recoder toutes mes fonctions ce soir sans compiler donc surement plein d'erreur

Elf_reader.h =>
/* Structure : Super-Structure des relocalisation. 
Ajout des informations concernant l'indice de la section de relocation et son nom, ainsi que le nombre de relocations à effectuer */
typedef struct reloctable {
  Elf32_Rel * tablerel;
  int indice_section;
  int nombre_relocation
  char * nom_section
} Reloctable ;


/* Ajout du type Reloctable à la place du type Elf32_Rel */
typedef struct fichierElf {
	Elf32_Ehdr	header_elf;
	Elf32_Shdr	*sectionsTable;
	Symbole	*tabSymbole;
	Elf32_Sym	*tabSymboleDynamique;
	FILE 	 	*fichierElf;
	Reloctable	*tabRel;
} FichierElf;

elf_fusionrel.c 


Reloctable* crea_rel_table (FichierElf * elfile) {
	// Creation de la table de REL
	// Avant : malloc le elf32_Rel de elfile en utilisant relsize.
	Elf32_Ehdr header = elfile->header_elf;
	Elf32_Shdr* section_headers = elfile->sectionsTable;
	// Faut-il le malloc ???
	Reloctable* tabrel = elfile->tabRel;
	FILE *elf = elfile->fichierElf;

	int nb_sec = header.e_shnum;	
	int nombre = 0;
	int trel = sizeof(Elf32_Rel);
	int k=0;
	int diffsec = 0;
	for (int i=0; i < nb_sec; i++){
		if (section_headers[i].sh_type == SHT_REL) {
			fseek(elf, section_headers[i].sh_offset, SEEK_SET);
			nombre = section_headers[i].sh_size / section_headers[i].sh_entsize;
			
			tabrel[diffsec].indice_section = i;
			tabrel[diffsec].nombre_relocation = nombre;
			tabrel[diffsec].nom_section = 
			for (int j=0; j < nombre; j++) {
				fread(&(tabrel.tablerel[k]),trel, 1,elf);
				k++;
			}
			diffsec ++;
		}


	}	
	return reltab;
}


Section RelUpdate (FichierElf* oldelf, FichierElf* newelf, Elf32_Shdr OldSec, int nbnewsymbole) {
// Si une section a besoin d'être mise a jour suite à la fusion. 
// Appel de type reloctable[i] ?? On va tester ça.


Elf32_Ehdr oldheader = oldelf->header_elf;
Elf32_Shdr* oldsection_headers = oldelf->sectionsTable;
Reloctable* oldlesrel = oldelf->tabRel;
Elf32_Sym *oldsym = oldelf->tabSymbole;
Elf32_Ehdr newheader = newelf->header_elf;
Elf32_Shdr* newsection_headers = newelf->sectionsTable;
Reloctable* newlesrel = newelf->tabRel;
Elf32_Sym *newsym = newelf->tabSymbole;

int parcoureltab = 0 ;
// A VERIFIER LA BOUCLE
while (strcmp(oldlesrel[parcoureltab].nom_section,getSectionName(OldSec,oldelf))==0){parcoureltab++;}

int indice_new_rel = 0;
while ( newlesrel[indice_new_rel].indice_section != -1 ) { indice_new_rel ++ ; }

int nombre = 0;
// Verifier la valeur de parcoureltab si on a i=0... Pour pas que ça prenne un de plus
int numsec = oldlesrel[parcoureltab].indice_section;
int type = 0;
int idsym = 0;
int j=0;
int found = 0;
// Inutile ??
nombre = oldsection_headers[numsec].sh_size / oldsection_headers[numsec].sh_entsize;

// Nombre de relocation inchangé
newlesrel[indice_new_rel].nombre_relocation = oldlesrel[parcoureltab].nombre_relocation;

//Nom de section inchangé 
newlesrel[indice_new_rel].nom_section = oldlesrel[parcoureltab].nom_section;

//Calcul du nouvel indice de section
int nouvel_ind_sec = 0;
while (strcmp(oldlesrel[parcoureltab].nom_section,getSectionName(newsection_headers[nouvel_ind_sec],newelf))==0) {
	nouvel_ind_sec ++;
	if (nouvel_ind_sec > 100 ) { printf ("Boucle dans le vide");  } } 
	newlesrel[indice_new_rel].indice_section = nouvel_ind_sec ;
// VERIFIER la valeur de nouvel_ind_sec 

	for (int i = 0; i<nombre ; i++) {
	// Calcul de l'offset de reimplementation
	// On va dire que l'offset ne change pas quand on ne fusionne pas 2 tables de relocation
		newlesrel[indice_new_rel].tablerel[i].r_offset = oldlesrel[parcoureltab].tablerel[i].r_offset;

	// Calcul du numero de symbole a partir de la nouvelle table des symboles.
	// Calcul du truc pour les sections. 
		type  = ELF32_R_TYPE(oldlesrel[parcoureltab].tablerel[i].r_info);
		idsym = ELF32_R_SYM(oldlesrel[parcoureltab].tablerel[i].r_info);
		
				// On fait symbole :D 
				j = 0;
				found = 0;
				
				while (j < nbnewsymbole && found == 0 ) {
					if ( ( oldsym[idsym].st_value == newsym[j].st_value ) &&( oldsym[idsym].st_size == newsym[j].st_size ) &&( oldsym[idsym].st_info == newsym[j].st_info ) ) {
						newlesrel[indice_new_rel].tablerel[i].r_info = ELF32_R_INFO(j,type);
						found = 1;
						
						}

					j++;
				} 
			switch (type) {
				// Que faire si on entre dans ces types ?
				// Prendre la section en question et prendre les 4 premiers octets
				// Les modifier dans le fichier ??
				// Il faut ajouter pour chacun l'offset de la table des symboles
				// plus le ndx du symbole en
			case (2) : 
				// R_ARM_ABS32
				break;
			case (5) :
				// R_ARM_ABS16
				break;
			case (6) :
				// R_ARM_ABS12
				break;
			case (8) :
				// R_ARM_ABS8
				break;
			
			case (29) :
				// R_ARM_JUMP24
				break;

			case (28) :
				// R_ARM_CALL -- PAS SUR DU TOUT CELUI LA
				break;

			default :
				break ;

		
		}
	}
}

